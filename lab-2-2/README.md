# Алгоритмы и структуры данных. Лабораторная работа №2

Лабораторная работа состоит из двух заданий, которые должны быть выполнены на одном 
из трёх уровней сложности. Уровень сложности выбирается обучающимся самостоятельно.

## Задание 1

Реализовать  алгоритмы  сортировки  согласно  своему  варианту  и  уровню сложности. 
Реализуемые сортировки определяются цифрами представления вашего номера варианта в системе счисления по основанию 3.

|   | **Группа 1**         | **Группа 2**         | **Группа 3 (только для среднего и высокого уровня сложности)**             |
| - | -                    | -                    | -                                                                          |
| 0 | Сортировка пузырьком | Сортировка Шелла     | Сортировка расчёской                                                       |
| 1 | Сортировка вставками | Шейкерная сортировка | Сортировка естественным двухпутевым слиянием (naturial two-way merge sort) |
| 2 | Сортировка выбором   | Быстрая сортировка   | Пирамидальная сортировка                                                   |

---

**Пример.** Допустимый набор вариантов `0-26` ($000_{3}$ — $222_{3}$). Предположим, что вам назначен вариант 19. 
Представим это число в системе счисления с основанием 3: 19 = 2 ·32 + 0·31 + 1·30 = 201.
Таким образом, в 19-ом варианте необходимо реализовать:

*на минимальном уровне сложности:*
- сортировку выбором (2);
- сортировку Шелла (0);

*на среднем и высоком уровне сложности:*
- сортировку выбором (2);
- сортировку Шелла (0);
- сортировку естественным двухпутевым слиянием (1).

## Задание 2

Посчитать число сравнений и число копирований объектов для массивов длины 1 000, 2 000, 3 000, …, 10 000:
- в среднем (сгенерировать 100 случайных массивов и посчитать среднее значение); 
- для полностью отсортированного массива;
- для обратно отсортированного массива.

По полученным данным построить графики, сравнить экспериментальные результаты с теорией, сделать выводы.

## Уровни сложности

### Минимальный уровень сложности

- Реализовать два алгоритма сортировки (из первой и второй групп) согласно своему варианту.
- Запрещено  использование  указателей,  любых  функций  из  `<algorithm>`  и  любых контейнеров стандартной библиотеки (см. исключение в пункте 3).
- Разрешается завести один или более дополнительных экземпляров  `std::vector<int>` — но только при условии, что они действительно необходимы.
- Публичные профили функций должны выглядеть так (например, для 19-го варианта):

```cpp

struct stats 
{
	size_t comparison_count = 0;
	size_t copy_count       = 0; 
};

stats selection_sort (std::vector<int>& data); 
stats     shell_sort (std::vector<int>& data);

```

Для других вариантов по-другому будут выглядеть  только названия  функций (выделены жирным цветом).
Возвращаемый тип и входной аргумент для любой функции сортировки из любого 
варианта должны в точности совпадать с приведённым выше примером.

### Средний уровень сложности

Реализовать третий алгоритм сортировки (из третьей группы) согласно своему варианту.

Например, для 19-го варианта профили функций будут выглядеть так: 

```cpp

stats     selection_sort (std::vector<int>& data);
stats         shell_sort (std::vector<int>& data); 
stats two_way_merge_sort (std::vector<int>& data);

```

### Высокий уровень сложности

В дополнение к требованиям среднего уровня сложности:

- Функции  должны  быть  шаблонными  и  абстрагированными  от  механизма  сравнения. 
Публичные профили функций должны выглядеть так (например, для 19 варианта):

```cpp

template<typename T, typename TCompare = std::less<T>>
stats     selection_sort (std::vector<T>& data);

template<typename T, typename TCompare = std::less<T>>
stats         shell_sort (std::vector<T>& data);

template<typename T, typename TCompare = std::less<T>>
stats two_way_merge_sort (std::vector<T>& data);

```

- Построить  графики  зависимости  количества  проведённых  сравнений  от  количества элементов  в  массиве.  **Графики  должны  совпадать  с  предсказаниями  теории.**  При необходимости искусственно замедлить операцию сравнения, предоставив собственный компаратор  с  `std::this_thread::sleep_for`.  Разрешается  по  своему  усмотрению скорректировать размеры массивов для получения адекватного времени замера.
  
___

**Работа выполнена на средний уровень, вариант №16.**
